#!/usr/bin/env sh

set -e

# Avoid any interactive credential prompts in hooks.
export GIT_TERMINAL_PROMPT=0

# 1) Ensure local branch is up to date with remote
# Pre-push hook receives remote name as $1
PUSH_REMOTE="${1:-origin}"
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

echo "üîç Checking if local branch is up to date with $PUSH_REMOTE/$CURRENT_BRANCH..."

# Fetch latest from the remote being pushed to
git fetch "$PUSH_REMOTE" "$CURRENT_BRANCH" 2>/dev/null || true

# Compare local and remote commits
LOCAL=$(git rev-parse HEAD)
REMOTE=$(git rev-parse "$PUSH_REMOTE/$CURRENT_BRANCH" 2>/dev/null || echo "$LOCAL")

if [ "$LOCAL" != "$REMOTE" ]; then
  # Check if remote is ahead (capture exit code properly to avoid set -e issues)
  if git merge-base --is-ancestor "$LOCAL" "$REMOTE" 2>/dev/null; then
    echo "‚ùå Error: Remote branch has new commits. Please pull first:"
    echo "   git pull $PUSH_REMOTE $CURRENT_BRANCH"
    exit 1
  fi
  # If we reach here, local is ahead or branches have diverged - allow push
  echo "‚ö†Ô∏è  Local and remote have diverged, but allowing push (you're ahead)"
fi

echo "‚úÖ Branch is up to date with $PUSH_REMOTE"

# 2) Read latest commit message
COMMIT_MESSAGE=$(git log -1 --pretty=%B 2>/dev/null || echo "")

# 3) Allow skipping
if [ -n "$COMMIT_MESSAGE" ] && printf '%s' "$COMMIT_MESSAGE" | grep -qiE '\[(skip ci|ci skip)\]|skip ci'; then
  echo "üõë Pre-push checks skipped because commit message contains [skip ci]."
  exit 0
fi

BASE_REMOTE="origin"
if ! git remote get-url "$BASE_REMOTE" >/dev/null 2>&1; then
  BASE_REMOTE="$PUSH_REMOTE"
fi
BASE_BRANCH="main"
BASE_REF="$BASE_REMOTE/$BASE_BRANCH"

# Keep parity with CI's PR-only validation steps.
# CI only runs these checks on pull_request, so we skip them on main.
if [ "$CURRENT_BRANCH" != "$BASE_BRANCH" ]; then
  echo "üîÑ Syncing base ref for changeset checks: $BASE_REF"
  # Avoid shallow fetches here. Changesets relies on git history to compute a
  # merge-base; fetching with `--depth=1` can make that impossible.
  if git rev-parse --is-shallow-repository 2>/dev/null | grep -q "true"; then
    echo "‚ö†Ô∏è  Repository is shallow; fetching full history for reliable changeset checks..."
    git fetch "$BASE_REMOTE" --unshallow --no-tags 2>/dev/null || \
      git fetch "$BASE_REMOTE" --depth=100000 --no-tags
  fi
  git fetch "$BASE_REMOTE" "$BASE_BRANCH" --no-tags

  CHANGED_FILES=$(git diff --name-only "$BASE_REF"...HEAD)

  TOUCHED_SDK=false
  TOUCHED_TYPES=false
  TOUCHED_CONTRACTS=false

  for file in $CHANGED_FILES; do
    case "$file" in
      packages/sdks/js-ts/*) TOUCHED_SDK=true ;;
      packages/types/*) TOUCHED_TYPES=true ;;
      packages/contracts/*) TOUCHED_CONTRACTS=true ;;
    esac
  done

  if [ "$TOUCHED_SDK" = "true" ] || [ "$TOUCHED_TYPES" = "true" ] || [ "$TOUCHED_CONTRACTS" = "true" ]; then
    echo "üßæ Summarizing pending changesets (since $BASE_REF)..."
    pnpm changeset status --since="$BASE_REF"

    if [ "$TOUCHED_TYPES" = "true" ] || [ "$TOUCHED_CONTRACTS" = "true" ]; then
      echo "üß© Ensuring SDK changes include required changesets (base: $BASE_REF)..."
      node .github/ensure-sdk-changeset.mjs "$BASE_REF"
    fi
  else
    echo "‚ÑπÔ∏è  No SDK/types/contracts changes detected; skipping changeset checks."
  fi
else
  echo "‚ÑπÔ∏è  On $BASE_BRANCH branch; skipping PR-only changeset checks."
fi

echo "‚ö° Running CI-equivalent checks..."
pnpm check:ci
