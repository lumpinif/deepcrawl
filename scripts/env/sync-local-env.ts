import { existsSync, readFileSync } from 'node:fs';
import { join } from 'node:path';
import {
  type EnvTarget,
  type EnvVarGroup,
  getEnvVarsForTarget,
} from '@deepcrawl/runtime/env';
import { formatDotenvValue, parseDotenv, writeFileIfChanged } from './_dotenv';

type OutputFile = {
  target: EnvTarget;
  filePath: string;
  headerLines: string[];
};

type SyncMode = 'local' | 'remote';

const GROUP_ORDER: EnvVarGroup[] = [
  'App',
  'Auth',
  'JWT',
  'Workers',
  'Logs',
  'OAuth',
  'Email',
  'Upstash',
  'Cloudflare',
  'Turbo',
  'SDK',
];

const LOCAL_APP_URL = 'http://localhost:3000';
const LOCAL_AUTH_WORKER_URL = 'http://localhost:8787';
const LOCAL_API_URL = 'http://localhost:8080';

function resolveSyncMode(raw: string | undefined): SyncMode {
  if (raw === 'remote') {
    return 'remote';
  }
  return 'local';
}

function isLocalUrl(value: string | undefined): boolean {
  if (!value) {
    return false;
  }

  return (
    value.startsWith('http://localhost') ||
    value.startsWith('https://localhost') ||
    value.startsWith('http://127.0.0.1') ||
    value.startsWith('https://127.0.0.1')
  );
}

function resolveLocalBetterAuthUrl(values: Record<string, string>): string {
  const useAuthWorker = values.NEXT_PUBLIC_USE_AUTH_WORKER !== 'false';
  return useAuthWorker ? LOCAL_AUTH_WORKER_URL : LOCAL_APP_URL;
}

function applyLocalOverridesForTarget(
  target: EnvTarget,
  values: Record<string, string>,
  mode: SyncMode,
): Record<string, string> {
  if (mode !== 'local') {
    return values;
  }

  const out: Record<string, string> = { ...values };

  if (target === 'dashboard') {
    if (!isLocalUrl(out.NEXT_PUBLIC_APP_URL)) {
      out.NEXT_PUBLIC_APP_URL = LOCAL_APP_URL;
    }

    if (!isLocalUrl(out.NEXT_PUBLIC_DEEPCRAWL_API_URL)) {
      out.NEXT_PUBLIC_DEEPCRAWL_API_URL = LOCAL_API_URL;
    }

    if (!isLocalUrl(out.BETTER_AUTH_URL)) {
      out.BETTER_AUTH_URL = resolveLocalBetterAuthUrl(out);
    }

    // Next.js client code can only read NEXT_PUBLIC_* variables.
    // Keep this in sync with BETTER_AUTH_URL.
    if (!out.NEXT_PUBLIC_BETTER_AUTH_URL) {
      out.NEXT_PUBLIC_BETTER_AUTH_URL =
        out.BETTER_AUTH_URL ?? resolveLocalBetterAuthUrl(out);
    }

    return out;
  }

  if (target === 'worker-auth') {
    if (!isLocalUrl(out.NEXT_PUBLIC_APP_URL)) {
      out.NEXT_PUBLIC_APP_URL = LOCAL_APP_URL;
    }

    if (!isLocalUrl(out.BETTER_AUTH_URL)) {
      out.BETTER_AUTH_URL = LOCAL_AUTH_WORKER_URL;
    }

    return out;
  }

  if (target === 'worker-v0') {
    if (!isLocalUrl(out.NEXT_PUBLIC_APP_URL)) {
      out.NEXT_PUBLIC_APP_URL = LOCAL_APP_URL;
    }

    if (!isLocalUrl(out.BETTER_AUTH_URL)) {
      out.BETTER_AUTH_URL = resolveLocalBetterAuthUrl(out);
    }

    return out;
  }

  return out;
}

const renderTargetEnvFile = (
  target: EnvTarget,
  headerLines: string[],
  values: Record<string, string>,
  opts?: {
    includeVar?: (key: string) => boolean;
  },
) => {
  const vars = getEnvVarsForTarget(target).filter((v) =>
    opts?.includeVar ? opts.includeVar(v.key) : true,
  );
  const lines: string[] = [...headerLines, ''];

  for (const group of GROUP_ORDER) {
    const groupVars = vars.filter((v) => v.group === group);
    if (groupVars.length === 0) {
      continue;
    }

    lines.push(`# ${group}`);

    for (const v of groupVars) {
      if (v.description) {
        lines.push(`# ${v.description}`);
      }

      const value = values[v.key] ?? '';
      lines.push(`${v.key}=${formatDotenvValue(value)}`);
      lines.push('');
    }
  }

  return `${lines.join('\n').trimEnd()}\n`;
};

const repoRoot = process.cwd();
const primarySourcePath = join(repoRoot, 'env', '.env');
const legacySourcePath = join(repoRoot, 'env', '.env.local');
const sourcePath = existsSync(primarySourcePath)
  ? primarySourcePath
  : existsSync(legacySourcePath)
    ? legacySourcePath
    : primarySourcePath;

if (!existsSync(sourcePath)) {
  console.error(
    `[env] Missing ${sourcePath}. Create it to sync local env files.\n` +
      '\n' +
      'Quick start:\n' +
      '  pnpm env:generate\n' +
      '  cp env/.env.example env/.env\n' +
      '  # edit env/.env\n' +
      '  pnpm env:sync:local\n',
  );
  process.exit(1);
}

const sourceContent = readFileSync(sourcePath, 'utf-8');
const values = parseDotenv(sourceContent);
const syncMode = resolveSyncMode(process.env.DEEPCRAWL_ENV_SYNC_MODE);

const dotenvOutputs: OutputFile[] = [
  {
    target: 'dashboard',
    // Used by Drizzle/Better Auth CLI scripts and Next.js dev server.
    filePath: join(repoRoot, 'apps', 'app', '.env'),
    headerLines: [
      '# Auto-generated by `pnpm env:sync:local`',
      `# Source: ${sourcePath}`,
      `# Mode: ${syncMode}`,
    ],
  },
  {
    target: 'worker-auth',
    filePath: join(repoRoot, 'apps', 'workers', 'auth', '.dev.vars'),
    headerLines: [
      '# Auto-generated by `pnpm env:sync:local`',
      `# Source: ${sourcePath}`,
      `# Mode: ${syncMode}`,
      '# Note: Secrets only. Non-secrets are configured in wrangler.jsonc vars.',
    ],
  },
  {
    target: 'worker-v0',
    filePath: join(repoRoot, 'apps', 'workers', 'v0', '.dev.vars'),
    headerLines: [
      '# Auto-generated by `pnpm env:sync:local`',
      `# Source: ${sourcePath}`,
      `# Mode: ${syncMode}`,
      '# Note: Secrets only. Non-secrets are configured in wrangler.jsonc vars.',
    ],
  },
];

let changed = 0;

for (const out of dotenvOutputs) {
  const resolvedValues = applyLocalOverridesForTarget(
    out.target,
    values,
    syncMode,
  );
  const content = (() => {
    if (out.target !== 'worker-auth' && out.target !== 'worker-v0') {
      return renderTargetEnvFile(out.target, out.headerLines, resolvedValues);
    }

    const secretKeys = new Set(
      getEnvVarsForTarget(out.target)
        .filter((v) => v.secret)
        .map((v) => v.key),
    );

    return renderTargetEnvFile(out.target, out.headerLines, resolvedValues, {
      includeVar: (key) => secretKeys.has(key),
    });
  })();
  const didWrite = writeFileIfChanged(out.filePath, content);
  if (didWrite) {
    changed += 1;
    console.log(`[env] wrote ${out.filePath}`);
  } else {
    console.log(`[env] up-to-date ${out.filePath}`);
  }
}

if (changed === 0) {
  console.log('[env] no changes');
}
